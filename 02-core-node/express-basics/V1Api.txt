VERSION ONE API 

exports.aliasRoute = (req, res, next) => {
  req.query.limit = '5';
  req.query.sort = '-ratingsAverage,price';
  req.query.fields =
    'name,duration,maxGroupSize,difficulty,ratingsQuantity,summary';
  next();
};


exports.getAllTours = async (req, res) => {
  try {
    // BUILD THE QUERY
    // 1A) first filtering for beginners
    const queryObj = { ...req.query };
    const excludedFields = ['page', 'sort', 'limit', 'fields'];

    excludedFields.forEach((el) => delete queryObj[el]);

    // const query = Tour.find()
    //   .where('duration')
    //   .equals(5)
    //   .where('price')
    //   .equals(445);

    // 1B) ADVANCED FILTERING FOR ADVANCED LOL

    let queryString = JSON.stringify(queryObj);
    queryString = queryString.replace(
      /\b(gte|gt|lte|lt)\b/g,
      (match) => `$${match}`
    );
    console.log(JSON.parse(queryString));
    let query = Tour.find(JSON.parse(queryString));
    // EXECUTE THE QUERY

    // 2) SORTING THIS IS THE SYNTHAX FOR SORTING
    if (req.query.sort) {
      let sortBy = req.query.sort.split(',').join(' ');
      query = query.sort(sortBy);
    } else query = query.sort('-createdAt');

    // 3) FIELDS LIMITING
    if (req.query.fields) {
      const fields = req.query.fields.split(',').join(' ');
      query = query.select(fields);
    } else {
      query = query.select('-__v'); // this remove the __v from the client interface.. but i also did it in the schema model check out
    }
    //  4) pagination
    const page = req.query.page * 1 || 1;
    const limit = req.query.limit * 1 || 100;
    const skip = (page - 1) * limit;

    query = query.skip(skip).limit(limit);

    if (req.query.page) {
      const numberOfDocuments = await Tour.countDocuments();
      if (skip >= numberOfDocuments)
        throw new Error('This page is not defined');
    }
    const tours = await query;
    // SEND RESPONSE
    res.status(200).json({
      success: true,
      result: tours.length,
      data: {
        tours,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error.message,
    });
  }
};

exports.getTour = async (req, res) => {
  try {
    const tour = await Tour.findById(req.params.id);
    // Tour.findOne({_id: req.params.id}) another way to do it lol

    res.status(200).json({
      success: true,
      data: {
        tour,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error.message,
    });
  }

  const tour = tours.find((el) => el.id === id);
};
exports.createTour = async (req, res) => {
  // const newTour = new Tour({})
  // newTour.save()

  try {
    const newTour = await Tour.create(req.body);

    res.status(201).json({
      success: true,
      data: {
        tours: newTour,
      },
    });
  } catch (err) {
    res.status(400).json({
      success: 'fail',
      message: err.message,
    });
  }
};

exports.updateTour = async (req, res) => {
  try {
    const updatedTour = await Tour.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });

    res.status(200).json({
      success: true,
      data: {
        updatedTour,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error,
    });
  }
};

exports.deleteTour = async (req, res) => {
  try {
    await Tour.findByIdAndDelete(req.params.id);
    res.status(200).json({
      success: true,
      data: {
        tour: null,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error,
    });
  }
};


BEFORE ERROR HANDLING MODIFICATION OF THE TRY BLOCK


const Tour = require('./../MODELS/tourModel');
const APIfeatures = require('./../UTILS/apiFeatures');
// TOURS CONTROLLERS
/*
const tours = JSON.parse(
  fs.readFileSync(`${__dirname}/../../dev-data/data/tours-simple.json`)
);
*/
// FIRST MIDDLE MIDDLEWARES FOR THE TOURS

/*
exports.checkId = (req, res, next, val) => {
  if (req.params.id * 1 > tours.length) {
    return res.status(404).json({
      success: 'fail',
      message: 'no tour found',
    });
  }
  next();
};
*/

// SECOND MIDDLEWARE THAT WAS A CHALLANGE LOL

/*

exports.checkBody = (req, res, next) => {
  const { name, price } = req.body;

  if (!name || !price) {
    return res.status(404).json({
      success: 'fail',
      message: 'no tour found',
    });
  }
  next();
};
*/

exports.aliasRoute = (req, res, next) => {
  req.query.limit = '5';
  req.query.sort = '-ratingsAverage,price';
  req.query.fields =
    'name,duration,maxGroupSize,difficulty,ratingsQuantity,summary';
  next();
};

exports.getAllTours = async (req, res) => {
  try {
    // EXECUTE THE QUERY
    const features = new APIfeatures(Tour.find(), req.query)
      .filter()
      .sort()
      .fieldsLimit()
      .paginate();
    const tours = await features.query;
    // SEND RESPONSE
    res.status(200).json({
      success: true,
      result: tours.length,
      data: {
        tours,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error.message,
    });
  }
};

exports.getTour = async (req, res) => {
  try {
    const tour = await Tour.findById(req.params.id);
    // Tour.findOne({_id: req.params.id}) another way to do it lol

    res.status(200).json({
      success: true,
      data: {
        tour,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error.message,
    });
  }

  // const tour = tours.find((el) => el.id === id);
};
exports.createTour = async (req, res) => {
  // const newTour = new Tour({})
  // newTour.save()

  try {
    const newTour = await Tour.create(req.body);

    res.status(201).json({
      success: true,
      data: {
        tours: newTour,
      },
    });
  } catch (err) {
    res.status(400).json({
      success: 'fail',
      message: err.message,
    });
  }
};

exports.updateTour = async (req, res) => {
  try {
    const updatedTour = await Tour.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });

    res.status(200).json({
      success: true,
      data: {
        updatedTour,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error,
    });
  }
};

exports.deleteTour = async (req, res) => {
  try {
    await Tour.findByIdAndDelete(req.params.id);
    res.status(200).json({
      success: true,
      data: {
        tour: null,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error,
    });
  }
};

exports.getTourStats = async (req, res) => {
  try {
    const stats = await Tour.aggregate([
      {
        $match: { ratingsAverage: { $gte: 4.5 } },
      },
      {
        $group: {
          _id: { $toUpper: '$difficulty' },
          numTours: { $sum: 1 },
          numRatings: { $sum: '$ratingsQuantity' },
          avgRating: { $avg: '$ratingsAverage' },
          avgPrice: { $avg: '$price' },
          minPrice: { $min: '$price' },
          maxPrice: { $max: '$price' },
        },
      },
      {
        $sort: { avgPrice: 1 },
      },
      // {
      //   $match: {_id: {$ne: 'EASY'}}
      // }
    ]);
    res.status(200).json({
      success: true,
      data: {
        stats,
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error,
    });
  }
};

exports.getMonthlyPlan = async (req, res) => {
  try {
    const year = req.params.year * 1; // this give you a number remember... if the params is 2020 it will be 2020 that is to say its a number and not a string

    const plan = await Tour.aggregate([
      {
        $unwind: '$startDates'
      },
      {
        $match: {
          startDates: {
            $gte: new Date(`${year}-01-01`),
            $lte: new Date(`${year}-12-31`)
          }
        }
      },
      {
        $group:{
          _id: {$month: '$startDates'},
          numOfToursStart: {$sum: 1},
          tours: {$push: '$name'}
        }
      },
      {
        $addFields: {month: '$_id'}
      },
      {
        $project: {
        _id: 0
        }
      },
      {
        $sort: {numOfToursStart: -1}
      },
      {
        $limit: 12
      }
    ])




    res.status(200).json({
      success: true,
      data: {
       plan
      },
    });
  } catch (error) {
    res.status(404).json({
      success: 'fail',
      message: error,
    });
  }
};

USER AUTHENTICATION AND NOTE THAT WE ALSO DID ALOT OF WORK IN MIDDLEWARES AND ALSO SOME ON MODELS AND THERE TWO ROUTE THAT WE WORKED ON IN THE USERCONTROLLER TOO NAMED UPDATEME AND DELETEME CHECK THEM OUT TOO

const crypto = require('crypto');
const { promisify } = require('util');
const jwt = require('jsonwebtoken');
const catchAsync = require('../UTILS/catchAsync');
const User = require('./../MODELS/userModel');
const AppError = require('./../UTILS/AppError');
const sendEmail = require('./../UTILS/email');

const signToken = (id) =>
  jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });

const createSendToken = (user, statusCode, res) => {
  const token = signToken(user._id);
  res.status(statusCode).json({
    status: 'success',
    token,
  });
};

exports.signup = catchAsync(async (req, res, next) => {
  const newUser = await User.create({
    name: req.body.name,
    email: req.body.email,
    password: req.body.password,
    passwordConfirm: req.body.passwordConfirm,
    passwordChangedAt: req.body.passwordChangedAt,
    role: req.body.role,
  });
  createSendToken(newUser, 201, res);
});

exports.signin = catchAsync(async (req, res, next) => {
  // 1) checking if the email and password exists
  const { email, password } = req.body;
  if (!email || !password) {
    return next(new AppError('Please provide valid email or password', 400));
  }

  // 2) check if user exist and if password is correct
  const user = await User.findOne({ email }).select('+password');

  if (!user || !(await user.correctPassword(password, user.password))) {
    return next(new AppError('Email OR Password is incorrect'));
  }

  // 3) sening back the user
  createSendToken(user, 200, res);
});

exports.protect = catchAsync(async (req, res, next) => {
  // 1) Getting  the token and checking if its there
  let token;
  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith('Bearer')
  ) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return next(
      new AppError('You are not login, please login to access route', 401)
    );
  }
  // console.log(token)
  // 2) Verifying the token

  const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);
  // console.log(decoded)
  // 3) check if the user still exists
  const currentUser = await User.findById(decoded.id);
  if (!currentUser) {
    return next(
      new AppError(
        'The user belonging to this token does no longer exist!',
        401
      )
    );
  }
  // 4) check if user changed password after the token was issued
  if (currentUser.changedPasswordAfter(decoded.iat)) {
    return next(
      new AppError(
        'User recently changed there password! please login again ...',
        401
      )
    );
  }

  // GRANTING ACCESS TO PROTECTED ROUTE
  req.user = currentUser;
  next();
});

exports.restrictTo = (...roles) => {
    // roles is an array and for example admin and lead-guide in the model and we picked the needed fields in the delete route side of the tours
    return catchAsync(async (req, res, next) => {
      if (!roles.includes(req.user.role)) {
        return next(
          new AppError('You dont have the permission to perform this action', 403)
        );
      }
      next();
    });
  };

exports.forgotPassword = catchAsync(async (req, res, next) => {
  // get user besed on posted email
  const user = await User.findOne({ email: req.body.email });

  if (!user) {
    return next(new AppError('Email does not exist', 404));
  }

  // generate random token
  const resetToken = user.createPasswordResetToken();
  await user.save({ validateBeforeSave: false });

  //send it back as an email
  const resetURL = `${req.protocol}://${req.get(
    'host'
  )}/api/v1/users/resetPassword/${resetToken}`;
  const message = `forgeot your password? submit a patch request with your new password and a confirm password to this url ${resetURL} \n if you didn't forget your password please ignore this email `;

  console.log('About to send email...');

  try {
    await sendEmail({
      email: user.email,
      subject: `your password reset token is valid for just 10 mins `,
      message,
    });
    res.status(200).json({
      status: 'success',
      message: 'Token sent successfully',
    });
    console.log('token sent successfullly');
  } catch (error) {
    user.resetPasswordToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save({ validateBeforeSave: false });

    return next(
      new AppError(
        'there was an error while sending the email please try again later',
        500
      )
    );
  }
});

exports.resetPassword = catchAsync(async (req, res, next) => {
  // 1 GET USER BASED ON TOKEN

  const hashedToken = crypto
    .createHash('sha256')
    .update(req.params.token)
    .digest('hex');

  const user = await User.findOne({
    resetPasswordToken: hashedToken,
    passwordResetExpires: { $gt: Date.now() },
  });
  // IF TOKEN HAS NOT EXPIRED AND THERE IS A USER, SET THE NEW USER
  if (!user) {
    return next(new AppError('Token is invalid or expired', 400));
  }
  user.password = req.body.password;
  user.passwordConfirm = req.body.passwordConfirm;
  user.resetPasswordToken = undefined;
  user.passwordResetExpires = undefined;
  await user.save();

  // 3  UPDATE CHANGEPASSWORDAT IN THE MODEL FOR THE USER and not that i commented the middleware that is suppsed to do this in the user model lol just note
  if (user.isModified('password') && !user.isNew) {
    user.passwordChangedAt = Date.now() - 1000;
  }
  // 4 LOG THE USER IN SENDING JSON WEB TOKEN TO THE CLIENT
    createSendToken(user, 200, res);

});



exports.updatePassword = catchAsync(async (req, res, next) => {
  // 1) GET USER FROM COLLECTION (req.user is available from protect middleware) so the protect middleware must be before the updatePassword route remember i made the mistake too
  const user = await User.findById(req.user.id).select('+password');

  // 2) CHECK IF THE POSTED CURRENT PASSWORD IS CORRECT
  if (!(await user.correctPassword(req.body.passwordCurrent, user.password))) {
    return next(new AppError('Your current password is wrong', 401));
  }

  // 3) IF CORRECT, UPDATE PASSWORD
  user.password = req.body.password;
  user.passwordConfirm = req.body.passwordConfirm;
  await user.save(); // triggers pre-save middleware for hashing

  // 4) LOG USER IN AGAIN
  createSendToken(user, 200, res);
});





